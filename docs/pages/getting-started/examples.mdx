# Examples

Comprehensive examples showing how to use Evolution SDK for common Cardano development tasks.

## Address Validation and Analysis

### Validating Different Address Types

```typescript
import * as PaymentAddress from "@evolution-sdk/evolution/PaymentAddress"
import * as RewardAddress from "@evolution-sdk/evolution/RewardAddress"

// Collection of different address types from mainnet and testnet
const addresses = {
  // Mainnet addresses
  mainnet: {
    base: "addr1qx2fxv2umyhttkxyxp8x0dlpdt3k6cwng5pxj3jhsydzer3n0d3vllmyqwsx5wktcd8cc3sq835lu7drv2xwl2wywfgse35a3x",
    enterprise: "addr1vx2fxv2umyhttkxyxp8x0dlpdt3k6cwng5pxj3jhsydzer66hrl8",
    pointer: "addr1gx2fxv2umyhttkxyxp8x0dlpdt3k6cwng5pxj3jhsydzer5pnz75xxcrzqf96k",
    reward: "stake1uyehkck0lajq8gr28t9uxnuvgcqrc6070x3k9r8048z8y5gh6ffgw"
  },
  // Testnet addresses
  testnet: {
    base: "addr_test1qz2fxv2umyhttkxyxp8x0dlpdt3k6cwng5pxj3jhsydzer3n0d3vllmyqwsx5wktcd8cc3sq835lu7drv2xwl2wywfgs68faae",
    enterprise: "addr_test1vz2fxv2umyhttkxyxp8x0dlpdt3k6cwng5pxj3jhsydzerspjrlsz",
    pointer: "addr_test1gz2fxv2umyhttkxyxp8x0dlpdt3k6cwng5pxj3jhsydzer5pnz75xxcrdw5vky",
    reward: "stake_test1uqehkck0lajq8gr28t9uxnuvgcqrc6070x3k9r8048z8y5gssrtvn"
  }
}

// Validate payment addresses (base, enterprise, pointer)
function validatePaymentAddresses() {
  const paymentAddresses = [
    addresses.mainnet.base,
    addresses.mainnet.enterprise,
    addresses.mainnet.pointer,
    addresses.testnet.base,
    addresses.testnet.enterprise,
    addresses.testnet.pointer
  ]

  paymentAddresses.forEach((address) => {
    const isValid = PaymentAddress.isPaymentAddress(address)
    console.log(`${address.substring(0, 20)}... is payment address: ${isValid}`)
  })
}

// Validate reward addresses
function validateRewardAddresses() {
  const rewardAddresses = [addresses.mainnet.reward, addresses.testnet.reward]

  rewardAddresses.forEach((address) => {
    const isValid = RewardAddress.isRewardAddress(address)
    console.log(`${address.substring(0, 20)}... is reward address: ${isValid}`)
  })
}

validatePaymentAddresses()
validateRewardAddresses()
```

## Address Format Conversion

### Working with Hex and Bech32 Formats

```typescript
import * as Address from "@evolution-sdk/evolution/Address"

// Sample hex addresses from the Cardano blockchain
const validHexAddresses = [
  "019493315cd92eb5d8c4304e67b7e16ae36d61d34502694657811a2c8e337b62cfff6403a06a3acbc34f8c46003c69fe79a3628cefa9c47251",
  "60ba1d6b6283c219a0530e3682c316215d55819cf97bbf26552c6f8530"
]

function demonstrateConversion() {
  validHexAddresses.forEach((hex) => {
    try {
      // Decode from hex
      const address = Address.Codec.Decode.hex(hex)
      console.log(`Decoded address from hex: ${hex.substring(0, 20)}...`)

      // Encode to bech32
      const bech32 = Address.Codec.Encode.bech32(address)
      console.log(`Bech32 format: ${bech32}`)

      // Round-trip back to hex
      const backToHex = Address.Codec.Encode.hex(address)
      console.log(`Round-trip successful: ${backToHex === hex}`)
      console.log("---")
    } catch (error) {
      console.error(`Failed to process hex: ${hex}`, error)
    }
  })
}

demonstrateConversion()
```

### Specific Hex to Bech32 Example

```typescript
import * as Address from "@evolution-sdk/evolution/Address"

// Real example from Cardano testnet
const hexAddress = "60ba1d6b6283c219a0530e3682c316215d55819cf97bbf26552c6f8530"
const expectedBech32 = "addr_test1vzap66mzs0ppngznpcmg9scky9w4tqvul9am7fj493hc2vq4ry02m"

const address = Address.Codec.Decode.hex(hexAddress)
const actualBech32 = Address.Codec.Encode.bech32(address)

console.log(`Input hex: ${hexAddress}`)
console.log(`Expected: ${expectedBech32}`)
console.log(`Actual:   ${actualBech32}`)
console.log(`Match: ${actualBech32 === expectedBech32}`)
```

## Data Type Validation

### Working with PlutusData Types

```typescript
import * as Data from "@evolution-sdk/evolution/Data"

// Create a codec for data operations
const codec = Data.Codec()

// Valid hex examples (even-length hex strings)
const validHexCases = ["deadbeef", "cafe0123", "abcdef0123456789", "00", "ff"]

// Invalid hex examples
const invalidHexCases = [
  "not-hex",
  "xyz",
  "123g",
  "deadbeef ", // trailing space
  " deadbeef", // leading space
  "0x123456" // hex prefix not allowed
]

function validateHexData() {
  console.log("Valid hex data:")
  validHexCases.forEach((hex) => {
    const isValid = Data.isBytes(hex)
    console.log(`"${hex}" -> ${isValid}`)
  })

  console.log("\nInvalid hex data:")
  invalidHexCases.forEach((hex) => {
    const isValid = Data.isBytes(hex)
    console.log(`"${hex}" -> ${isValid}`)
  })
}

validateHexData()
```

## Error Handling Patterns

### Safe Address Operations with Effect

```typescript
import { Effect } from "effect"
import * as Address from "@evolution-sdk/evolution/Address"

// Safe address decoding with error handling
function safeAddressOperations() {
  const addresses = [
    "60ba1d6b6283c219a0530e3682c316215d55819cf97bbf26552c6f8530", // valid
    "invalid-hex-address", // invalid
    "019493315cd92eb5d8c4304e67b7e16ae36d61d34502694657811a2c8e337b62cfff6403a06a3acbc34f8c46003c69fe79a3628cefa9c47251" // valid
  ]

  addresses.forEach((hex) => {
    const program = Effect.gen(function* () {
      // Try to decode the address
      const address = yield* Effect.try(() => Address.Codec.Decode.hex(hex))

      // If successful, convert to bech32
      const bech32 = Address.Codec.Encode.bech32(address)

      return {
        success: true,
        input: hex,
        output: bech32
      }
    })

    // Handle the result
    Effect.runPromise(program)
      .then((result) => {
        console.log(`✅ Success: ${result.input.substring(0, 20)}... -> ${result.output}`)
      })
      .catch((error) => {
        console.log(`❌ Failed: ${hex.substring(0, 20)}... -> ${error.message || "Invalid address"}`)
      })
  })
}

safeAddressOperations()
```

### Batch Address Validation

```typescript
import * as PaymentAddress from "@evolution-sdk/evolution/PaymentAddress"
import * as RewardAddress from "@evolution-sdk/evolution/RewardAddress"

// Mixed collection of valid and invalid addresses
const testAddresses = [
  "addr1qx2fxv2umyhttkxyxp8x0dlpdt3k6cwng5pxj3jhsydzer3n0d3vllmyqwsx5wktcd8cc3sq835lu7drv2xwl2wywfgse35a3x",
  "stake1uyehkck0lajq8gr28t9uxnuvgcqrc6070x3k9r8048z8y5gh6ffgw",
  "not-an-address",
  "addr_test1qz2fxv2umyhttkxyxp8x0dlpdt3k6cwng5pxj3jhsydzer3n0d3vllmyqwsx5wktcd8cc3sq835lu7drv2xwl2wywfgs68faae",
  "stake_test1uqehkck0lajq8gr28t9uxnuvgcqrc6070x3k9r8048z8y5gssrtvn"
]

function batchValidation() {
  const results = testAddresses.map((address) => {
    const isPayment = PaymentAddress.isPaymentAddress(address)
    const isReward = RewardAddress.isRewardAddress(address)

    let type = "invalid"
    if (isPayment) type = "payment"
    else if (isReward) type = "reward"

    return {
      address: address.substring(0, 30) + "...",
      type,
      valid: isPayment || isReward
    }
  })

  console.log("Batch validation results:")
  console.table(results)
}

batchValidation()
```

## Next Steps

- Check out the [API Reference](/api) for complete documentation
- Learn about [Address Types](/getting-started/address-types) in detail
- Explore [Advanced Usage](/guides/advanced) patterns
- View the [Test Suite](https://github.com/your-repo/tests) for more examples
