# CBOR Encoding Options

Compare different CBOR encoding strategies for the same data.

```typescript
// #region main
// Create complex data with unsorted elements (Maps should be standalone, not in constructor fields)
const unsortedMap = new Map<Data.Data, Data.Data>([
  ["7a65627261", 1n], // 'zebra' in hex
  ["6170706c65", 2n], // 'apple' in hex
  ["62616e616e61", 3n] // 'banana' in hex
])

// Create a constructor with only valid field types
const complexData = new Data.Constr({
  index: 1n,
  fields: [
    // List with mixed order
    [100n, 1n, 50n, 25n],
    "deadbeef",
    42n // additional data
  ]
})

// Standard encoding (preserves original order)
const standardHex = Data.toCBORHex(complexData)
console.log("Standard CBOR:", standardHex)

// Canonical encoding (sorted for deterministic output)
const canonicalHex = Data.toCBORHex(complexData, CBOR.CANONICAL_OPTIONS)
console.log("Canonical CBOR:", canonicalHex)

// Test with the standalone map
const mapStandardHex = Data.toCBORHex(unsortedMap)
const mapCanonicalHex = Data.toCBORHex(unsortedMap, CBOR.CANONICAL_OPTIONS)

// Both should decode to equivalent data
const fromStandard = Data.fromCBORHex(standardHex)
const fromCanonical = Data.fromCBORHex(canonicalHex)

assert.deepStrictEqual(fromStandard, complexData)
assert.deepStrictEqual(fromCanonical, complexData)
assert.deepStrictEqual(fromStandard, fromCanonical)

// Demonstrate that canonical encoding is deterministic
const secondCanonical = Data.toCBORHex(complexData, CBOR.CANONICAL_OPTIONS)
assert.equal(canonicalHex, secondCanonical)

console.log("Map encoding also works:", mapStandardHex.length > 0)

```
