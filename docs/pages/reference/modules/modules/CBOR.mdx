---
title: CBOR.ts
nav_order: 24
parent: Modules
---

## CBOR overview

---

<h2 className="text-delta">Table of contents</h2>

- [constants](#constants)
  - [CANONICAL_OPTIONS](#canonical_options)
  - [CBOR_ADDITIONAL_INFO](#cbor_additional_info)
  - [CBOR_MAJOR_TYPE](#cbor_major_type)
  - [CBOR_SIMPLE](#cbor_simple)
  - [DEFAULT_OPTIONS](#default_options)
- [errors](#errors)
  - [CBORError (class)](#cborerror-class)
- [model](#model)
  - [CBOR (type alias)](#cbor-type-alias)
  - [CodecOptions (type alias)](#codecoptions-type-alias)
- [schemas](#schemas)
  - [CBORSchema](#cborschema)
  - [FromBytes](#frombytes)
  - [Integer](#integer)
- [transformation](#transformation)
  - [match](#match)
- [utils](#utils)
  - [ArraySchema](#arrayschema)
  - [ByteArray](#bytearray)
  - [FromHex](#FromHex)
  - [Codec](#codec)
  - [Float](#float)
  - [MapSchema](#mapschema)
  - [RecordSchema](#recordschema)
  - [Simple](#simple)
  - [Tag (class)](#tag-class)
  - [Text](#text)
  - [isArray](#isarray)
  - [isByteArray](#isbytearray)
  - [isInteger](#isinteger)
  - [isMap](#ismap)
  - [isRecord](#isrecord)
  - [isTag](#istag)

---

# constants

## CANONICAL_OPTIONS

Canonical CBOR encoding options (RFC 8949 Section 4.2.1)

**Signature**

```ts
export declare const CANONICAL_OPTIONS: CodecOptions
```

Added in v1.0.0

## CBOR_ADDITIONAL_INFO

CBOR additional information constants

**Signature**

```ts
export declare const CBOR_ADDITIONAL_INFO: {
  readonly DIRECT: 24
  readonly UINT16: 25
  readonly UINT32: 26
  readonly UINT64: 27
  readonly INDEFINITE: 31
}
```

Added in v1.0.0

## CBOR_MAJOR_TYPE

CBOR major types as constants

**Signature**

```ts
export declare const CBOR_MAJOR_TYPE: {
  readonly UNSIGNED_INTEGER: 0
  readonly NEGATIVE_INTEGER: 1
  readonly BYTE_STRING: 2
  readonly TEXT_STRING: 3
  readonly ARRAY: 4
  readonly MAP: 5
  readonly TAG: 6
  readonly SIMPLE_FLOAT: 7
}
```

Added in v1.0.0

## CBOR_SIMPLE

Simple value constants for CBOR

**Signature**

```ts
export declare const CBOR_SIMPLE: { readonly FALSE: 20; readonly TRUE: 21; readonly NULL: 22; readonly UNDEFINED: 23 }
```

Added in v1.0.0

## DEFAULT_OPTIONS

Default CBOR encoding options

**Signature**

```ts
export declare const DEFAULT_OPTIONS: CodecOptions
```

Added in v1.0.0

# errors

## CBORError (class)

Error class for CBOR value operations

**Signature**

```ts
export declare class CBORError
```

Added in v1.0.0

# model

## CBOR (type alias)

Type representing a CBOR value with simplified, non-tagged structure

**Signature**

```ts
export type CBOR =
  | bigint // integers (both positive and negative)
  | Uint8Array // byte strings
  | string // text strings
  | ReadonlyArray<CBOR> // arrays
  | ReadonlyMap<CBOR, CBOR> // maps
  | { readonly [key: string]: CBOR } // record alternative to maps
  | Tag // tagged values
  | boolean // boolean values
  | null // null value
  | undefined // undefined value
  | number
```

Added in v1.0.0

## CodecOptions (type alias)

CBOR codec configuration options

**Signature**

```ts
export type CodecOptions =
  | {
      readonly mode: "canonical"
    }
  | {
      readonly mode: "custom"
      readonly useIndefiniteArrays: boolean
      readonly useIndefiniteMaps: boolean
      readonly useDefiniteForEmpty: boolean
      readonly sortMapKeys: boolean
      readonly useMinimalEncoding: boolean
    }
```

Added in v1.0.0

# schemas

## CBORSchema

CBOR Value discriminated union schema representing all possible CBOR data types
Inspired by OCaml and Rust CBOR implementations

**Signature**

```ts
export declare const CBORSchema: Schema.Schema<CBOR, CBOR, never>
```

Added in v1.0.0

## FromBytes

Create a CBOR bytes schema with custom codec options

**Signature**

```ts
export declare const FromBytes: (
  options: CodecOptions
) => Schema.transformOrFail<typeof Schema.Uint8ArrayFromSelf, Schema.declare<CBOR, CBOR, readonly [], never>, never>
```

Added in v1.0.0

## Integer

CBOR Value schema definitions for each major type

**Signature**

```ts
export declare const Integer: typeof Schema.BigIntFromSelf
```

Added in v1.0.0

# transformation

## match

Pattern matching utility for CBOR values

**Signature**

```ts
export declare const match: <R>(
  value: CBOR,
  patterns: {
    integer: (value: bigint) => R
    bytes: (value: Uint8Array) => R
    text: (value: string) => R
    array: (value: ReadonlyArray<CBOR>) => R
    map: (value: ReadonlyMap<CBOR, CBOR>) => R
    record: (value: { readonly [key: string]: CBOR }) => R
    tag: (tag: number, value: CBOR) => R
    boolean: (value: boolean) => R
    null: () => R
    undefined: () => R
    float: (value: number) => R
  }
) => R
```

Added in v1.0.0

# utils

## ArraySchema

**Signature**

```ts
export declare const ArraySchema: Schema.Array$<Schema.suspend<CBOR, CBOR, never>>
```

## ByteArray

**Signature**

```ts
export declare const ByteArray: typeof Schema.Uint8ArrayFromSelf
```

## FromHex

**Signature**

```ts
export declare const FromHex: (
  options: CodecOptions
) => Schema.transform<
  Schema.transform<Schema.refine<string, typeof Schema.String>, typeof Schema.Uint8ArrayFromSelf>,
  Schema.transformOrFail<typeof Schema.Uint8ArrayFromSelf, Schema.declare<CBOR, CBOR, readonly [], never>, never>
>
```

## Codec

**Signature**

```ts
export declare const Codec: (options?: CodecOptions) => {
  Encode: { cborBytes: (input: CBOR) => any; cborHex: (input: CBOR) => string }
  Decode: { cborBytes: (input: any) => CBOR; cborHex: (input: string) => CBOR }
  EncodeEffect: {
    cborBytes: (input: CBOR) => Effect.Effect<any, InstanceType<typeof CBORError>>
    cborHex: (input: CBOR) => Effect.Effect<string, InstanceType<typeof CBORError>>
  }
  DecodeEffect: {
    cborBytes: (input: any) => Effect.Effect<CBOR, InstanceType<typeof CBORError>>
    cborHex: (input: string) => Effect.Effect<CBOR, InstanceType<typeof CBORError>>
  }
  EncodeEither: {
    cborBytes: (input: CBOR) => Either<any, InstanceType<typeof CBORError>>
    cborHex: (input: CBOR) => Either<string, InstanceType<typeof CBORError>>
  }
  DecodeEither: {
    cborBytes: (input: any) => Either<CBOR, InstanceType<typeof CBORError>>
    cborHex: (input: string) => Either<CBOR, InstanceType<typeof CBORError>>
  }
}
```

## Float

**Signature**

```ts
export declare const Float: typeof Schema.Number
```

## MapSchema

**Signature**

```ts
export declare const MapSchema: Schema.ReadonlyMapFromSelf<
  Schema.suspend<CBOR, CBOR, never>,
  Schema.suspend<CBOR, CBOR, never>
>
```

## RecordSchema

**Signature**

```ts
export declare const RecordSchema: Schema.Record$<typeof Schema.String, Schema.suspend<CBOR, CBOR, never>>
```

## Simple

**Signature**

```ts
export declare const Simple: Schema.Union<[typeof Schema.Boolean, typeof Schema.Null, typeof Schema.Undefined]>
```

## Tag (class)

**Signature**

```ts
export declare class Tag
```

## Text

**Signature**

```ts
export declare const Text: typeof Schema.String
```

## isArray

**Signature**

```ts
export declare const isArray: (u: unknown, overrideOptions?: ParseOptions | number) => u is readonly CBOR[]
```

## isByteArray

**Signature**

```ts
export declare const isByteArray: (u: unknown, overrideOptions?: ParseOptions | number) => u is any
```

## isInteger

**Signature**

```ts
export declare const isInteger: (u: unknown, overrideOptions?: ParseOptions | number) => u is bigint
```

## isMap

**Signature**

```ts
export declare const isMap: (u: unknown, overrideOptions?: ParseOptions | number) => u is ReadonlyMap<CBOR, CBOR>
```

## isRecord

**Signature**

```ts
export declare const isRecord: (
  u: unknown,
  overrideOptions?: ParseOptions | number
) => u is { readonly [x: string]: CBOR }
```

## isTag

**Signature**

```ts
export declare const isTag: (u: unknown, overrideOptions?: ParseOptions | number) => u is Tag
```
